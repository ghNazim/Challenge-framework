<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Drag and Drop Matching Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #gameContainer {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .draggable {
            cursor: grab;
        }
        
        .draggable:hover:not(.dragging) {
            filter: brightness(1.1);
            
            transition: all 0.2s ease;
        }
        
        .dragging {
            cursor: grabbing;
            filter: brightness(1.2);
            
            transition: none;
        }
        
        .drop-zone {
            transition: none;
        }
        
        .drop-zone.highlight {
            filter: brightness(1.3);
            stroke-width: 4;
            stroke-dasharray: 10,5;
            animation: pulse 0.5s infinite alternate;
            transition: none;
        }
        
        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        .instructions {
            color: white;
            text-align: center;
            margin-top: 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¯ Shape Matching Game</h1>
    <div id="gameContainer">
        <svg width="800" height="500" id="gameSvg">
            <!-- Drop Zones -->
            <rect id="redZone" class="drop-zone" x="50" y="50" width="120" height="120" 
                  fill="#ffebee" stroke="#f44336" stroke-width="2" rx="10" data-shape="circle" data-color="red"/>
            <text x="110" y="175" text-anchor="middle" fill="#f44336" font-size="14" font-weight="bold">Red Circle</text>
            
            <rect id="blueZone" class="drop-zone" x="200" y="50" width="120" height="120" 
                  fill="#e3f2fd" stroke="#2196f3" stroke-width="2" rx="10" data-shape="square" data-color="blue"/>
            <text x="260" y="175" text-anchor="middle" fill="#2196f3" font-size="14" font-weight="bold">Blue Square</text>
            
            <polygon id="greenZone" class="drop-zone" points="380,50 440,50 470,110 440,170 380,170 350,110" 
                     fill="#e8f5e8" stroke="#4caf50" stroke-width="2" data-shape="triangle" data-color="green"/>
            <text x="410" y="185" text-anchor="middle" fill="#4caf50" font-size="14" font-weight="bold">Green Triangle</text>
            
            <ellipse id="yellowZone" class="drop-zone" cx="580" cy="110" rx="60" ry="40" 
                     fill="#fffde7" stroke="#ff9800" stroke-width="2" data-shape="ellipse" data-color="yellow"/>
            <text x="580" y="175" text-anchor="middle" fill="#ff9800" font-size="14" font-weight="bold">Yellow Oval</text>
            
            <!-- Draggable Objects -->
            <circle id="redCircle" class="draggable" cx="150" cy="350" r="30" 
                    fill="#f44336" stroke="#d32f2f" stroke-width="2" 
                    data-shape="circle" data-color="red" data-original-x="150" data-original-y="350"/>
            
            <rect id="blueSquare" class="draggable" x="220" y="320" width="60" height="60" 
                  fill="#2196f3" stroke="#1976d2" stroke-width="2" rx="5"
                  data-shape="square" data-color="blue" data-original-x="220" data-original-y="320"/>
            
            <polygon id="greenTriangle" class="draggable" points="380,320 350,380 410,380" 
                     fill="#4caf50" stroke="#388e3c" stroke-width="2"
                     data-shape="triangle" data-color="green" data-original-points="380,320 350,380 410,380"/>
            
            <ellipse id="yellowEllipse" class="draggable" cx="530" cy="350" rx="40" ry="25" 
                     fill="#ff9800" stroke="#f57c00" stroke-width="2"
                     data-shape="ellipse" data-color="yellow" data-original-cx="530" data-original-cy="350"/>
        </svg>
    </div>
    
    <div class="instructions">
        <p>ðŸŽ® Drag each shape to its matching colored zone!</p>
        <p>âœ¨ Drop zones will highlight when you hover over them with the correct shape</p>
    </div>

    <script>
        class DragDropGame {
            constructor() {
                this.svg = document.getElementById('gameSvg');
                this.draggables = document.querySelectorAll('.draggable');
                this.dropZones = document.querySelectorAll('.drop-zone');
                this.currentDragging = null;
                this.offset = { x: 0, y: 0 };
                this.init();
            }

            init() {
                this.draggables.forEach(element => {
                    element.addEventListener('mousedown', this.startDrag.bind(this));
                });

                document.addEventListener('mousemove', this.drag.bind(this));
                document.addEventListener('mouseup', this.endDrag.bind(this));
            }

            startDrag(e) {
                e.preventDefault();
                this.currentDragging = e.target;
                this.currentDragging.classList.add('dragging');

                const rect = this.svg.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate offset based on element type
                if (this.currentDragging.tagName === 'circle') {
                    this.offset.x = mouseX - parseFloat(this.currentDragging.getAttribute('cx'));
                    this.offset.y = mouseY - parseFloat(this.currentDragging.getAttribute('cy'));
                } else if (this.currentDragging.tagName === 'rect') {
                    this.offset.x = mouseX - parseFloat(this.currentDragging.getAttribute('x'));
                    this.offset.y = mouseY - parseFloat(this.currentDragging.getAttribute('y'));
                } else if (this.currentDragging.tagName === 'polygon') {
                    const points = this.parsePoints(this.currentDragging.getAttribute('points'));
                    const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                    const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                    this.offset.x = mouseX - centerX;
                    this.offset.y = mouseY - centerY;
                } else if (this.currentDragging.tagName === 'ellipse') {
                    this.offset.x = mouseX - parseFloat(this.currentDragging.getAttribute('cx'));
                    this.offset.y = mouseY - parseFloat(this.currentDragging.getAttribute('cy'));
                }

                // Bring to front
                this.svg.appendChild(this.currentDragging);
            }

            drag(e) {
                if (!this.currentDragging) return;

                e.preventDefault();
                const rect = this.svg.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const newX = mouseX - this.offset.x;
                const newY = mouseY - this.offset.y;

                // Update position based on element type - using requestAnimationFrame for smooth updates
                requestAnimationFrame(() => {
                    if (!this.currentDragging) return;
                    
                    if (this.currentDragging.tagName === 'circle') {
                        this.currentDragging.setAttribute('cx', newX);
                        this.currentDragging.setAttribute('cy', newY);
                    } else if (this.currentDragging.tagName === 'rect') {
                        this.currentDragging.setAttribute('x', newX);
                        this.currentDragging.setAttribute('y', newY);
                    } else if (this.currentDragging.tagName === 'polygon') {
                        const originalPoints = this.parsePoints(this.currentDragging.getAttribute('data-original-points'));
                        const originalCenter = {
                            x: originalPoints.reduce((sum, p) => sum + p.x, 0) / originalPoints.length,
                            y: originalPoints.reduce((sum, p) => sum + p.y, 0) / originalPoints.length
                        };
                        
                        const deltaX = newX - originalCenter.x;
                        const deltaY = newY - originalCenter.y;
                        
                        const newPoints = originalPoints.map(p => ({
                            x: p.x + deltaX,
                            y: p.y + deltaY
                        }));
                        
                        this.currentDragging.setAttribute('points', newPoints.map(p => `${p.x},${p.y}`).join(' '));
                    } else if (this.currentDragging.tagName === 'ellipse') {
                        this.currentDragging.setAttribute('cx', newX);
                        this.currentDragging.setAttribute('cy', newY);
                    }

                    // Check for drop zone highlighting
                    this.updateDropZoneHighlighting();
                });
            }

            endDrag(e) {
                if (!this.currentDragging) return;

                this.currentDragging.classList.remove('dragging');
                
                // Check if dropped on valid zone
                const validZone = this.getValidDropZone();
                
                if (validZone) {
                    this.snapToZone(this.currentDragging, validZone);
                    this.showSuccessEffect(validZone);
                } else {
                    this.returnToOriginalPosition(this.currentDragging);
                }

                // Clear highlighting
                this.dropZones.forEach(zone => zone.classList.remove('highlight'));
                this.currentDragging = null;
            }

            updateDropZoneHighlighting() {
                this.dropZones.forEach(zone => {
                    const isOverZone = this.isOverDropZone(this.currentDragging, zone);
                    const isValidMatch = this.isValidMatch(this.currentDragging, zone);
                    
                    if (isOverZone && isValidMatch) {
                        zone.classList.add('highlight');
                    } else {
                        zone.classList.remove('highlight');
                    }
                });
            }

            getValidDropZone() {
                for (let zone of this.dropZones) {
                    if (this.isOverDropZone(this.currentDragging, zone) && 
                        this.isValidMatch(this.currentDragging, zone)) {
                        return zone;
                    }
                }
                return null;
            }

            isOverDropZone(draggable, zone) {
                const draggablePos = this.getElementCenter(draggable);
                const zoneBounds = this.getZoneBounds(zone);
                
                return draggablePos.x >= zoneBounds.left && 
                       draggablePos.x <= zoneBounds.right &&
                       draggablePos.y >= zoneBounds.top && 
                       draggablePos.y <= zoneBounds.bottom;
            }

            isValidMatch(draggable, zone) {
                const draggableShape = draggable.getAttribute('data-shape');
                const draggableColor = draggable.getAttribute('data-color');
                const zoneShape = zone.getAttribute('data-shape');
                const zoneColor = zone.getAttribute('data-color');
                
                return draggableShape === zoneShape && draggableColor === zoneColor;
            }

            snapToZone(draggable, zone) {
                const zoneBounds = this.getZoneBounds(zone);
                const centerX = (zoneBounds.left + zoneBounds.right) / 2;
                const centerY = (zoneBounds.top + zoneBounds.bottom) / 2;

                if (draggable.tagName === 'circle') {
                    draggable.setAttribute('cx', centerX);
                    draggable.setAttribute('cy', centerY);
                } else if (draggable.tagName === 'rect') {
                    const width = parseFloat(draggable.getAttribute('width'));
                    const height = parseFloat(draggable.getAttribute('height'));
                    draggable.setAttribute('x', centerX - width / 2);
                    draggable.setAttribute('y', centerY - height / 2);
                } else if (draggable.tagName === 'polygon') {
                    const originalPoints = this.parsePoints(draggable.getAttribute('data-original-points'));
                    const originalCenter = {
                        x: originalPoints.reduce((sum, p) => sum + p.x, 0) / originalPoints.length,
                        y: originalPoints.reduce((sum, p) => sum + p.y, 0) / originalPoints.length
                    };
                    
                    const deltaX = centerX - originalCenter.x;
                    const deltaY = centerY - originalCenter.y;
                    
                    const newPoints = originalPoints.map(p => ({
                        x: p.x + deltaX,
                        y: p.y + deltaY
                    }));
                    
                    draggable.setAttribute('points', newPoints.map(p => `${p.x},${p.y}`).join(' '));
                } else if (draggable.tagName === 'ellipse') {
                    draggable.setAttribute('cx', centerX);
                    draggable.setAttribute('cy', centerY);
                }
            }

            returnToOriginalPosition(draggable) {
                if (draggable.tagName === 'circle') {
                    draggable.setAttribute('cx', draggable.getAttribute('data-original-x'));
                    draggable.setAttribute('cy', draggable.getAttribute('data-original-y'));
                } else if (draggable.tagName === 'rect') {
                    draggable.setAttribute('x', draggable.getAttribute('data-original-x'));
                    draggable.setAttribute('y', draggable.getAttribute('data-original-y'));
                } else if (draggable.tagName === 'polygon') {
                    draggable.setAttribute('points', draggable.getAttribute('data-original-points'));
                } else if (draggable.tagName === 'ellipse') {
                    draggable.setAttribute('cx', draggable.getAttribute('data-original-cx'));
                    draggable.setAttribute('cy', draggable.getAttribute('data-original-cy'));
                }
            }

            getElementCenter(element) {
                if (element.tagName === 'circle') {
                    return {
                        x: parseFloat(element.getAttribute('cx')),
                        y: parseFloat(element.getAttribute('cy'))
                    };
                } else if (element.tagName === 'rect') {
                    const x = parseFloat(element.getAttribute('x'));
                    const y = parseFloat(element.getAttribute('y'));
                    const width = parseFloat(element.getAttribute('width'));
                    const height = parseFloat(element.getAttribute('height'));
                    return { x: x + width / 2, y: y + height / 2 };
                } else if (element.tagName === 'polygon') {
                    const points = this.parsePoints(element.getAttribute('points'));
                    return {
                        x: points.reduce((sum, p) => sum + p.x, 0) / points.length,
                        y: points.reduce((sum, p) => sum + p.y, 0) / points.length
                    };
                } else if (element.tagName === 'ellipse') {
                    return {
                        x: parseFloat(element.getAttribute('cx')),
                        y: parseFloat(element.getAttribute('cy'))
                    };
                }
            }

            getZoneBounds(zone) {
                if (zone.tagName === 'rect') {
                    const x = parseFloat(zone.getAttribute('x'));
                    const y = parseFloat(zone.getAttribute('y'));
                    const width = parseFloat(zone.getAttribute('width'));
                    const height = parseFloat(zone.getAttribute('height'));
                    return { left: x, right: x + width, top: y, bottom: y + height };
                } else if (zone.tagName === 'polygon') {
                    const points = this.parsePoints(zone.getAttribute('points'));
                    const xs = points.map(p => p.x);
                    const ys = points.map(p => p.y);
                    return {
                        left: Math.min(...xs),
                        right: Math.max(...xs),
                        top: Math.min(...ys),
                        bottom: Math.max(...ys)
                    };
                } else if (zone.tagName === 'ellipse') {
                    const cx = parseFloat(zone.getAttribute('cx'));
                    const cy = parseFloat(zone.getAttribute('cy'));
                    const rx = parseFloat(zone.getAttribute('rx'));
                    const ry = parseFloat(zone.getAttribute('ry'));
                    return { left: cx - rx, right: cx + rx, top: cy - ry, bottom: cy + ry };
                }
            }

            parsePoints(pointsStr) {
                return pointsStr.trim().split(/\s+/).map(pair => {
                    const [x, y] = pair.split(',').map(Number);
                    return { x, y };
                });
            }

            showSuccessEffect(zone) {
                // Create a temporary success indicator
                const success = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const bounds = this.getZoneBounds(zone);
                const centerX = (bounds.left + bounds.right) / 2;
                const centerY = bounds.bottom + 20;
                
                success.setAttribute('x', centerX);
                success.setAttribute('y', centerY);
                success.setAttribute('text-anchor', 'middle');
                success.setAttribute('fill', '#4caf50');
                success.setAttribute('font-size', '16');
                success.setAttribute('font-weight', 'bold');
                success.textContent = 'âœ“ Perfect!';
                
                this.svg.appendChild(success);
                
                // Animate and remove
                setTimeout(() => {
                    if (success.parentNode) {
                        success.parentNode.removeChild(success);
                    }
                }, 1500);
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', () => {
            new DragDropGame();
        });
    </script>
</body>
</html>
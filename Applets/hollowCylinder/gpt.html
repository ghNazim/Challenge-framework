<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cylinder Unfolding Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #scene-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; }
        #controls { position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.8); padding: 20px; border-radius: 10px; }
        .slider-container { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-family: Arial, sans-serif; }
        input[type="range"] { width: 200px; }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="controls">
        <div class="slider-container">
            <label for="flapAngle">Disc Flap Angle (0-90Â°):</label>
            <input type="range" id="flapAngle" min="0" max="90" value="0">
        </div>
        <div class="slider-container">
            <label for="unwrapFactor">Surface Unwrap (0-1):</label>
            <input type="range" id="unwrapFactor" min="0" max="1" step="0.01" value="0">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);

        // Cylinder parameters
        const radius = 2;
        const height = 4;
        const segments = 32;

        // Materials
        const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x0077be });
        const sideMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa77, side: THREE.DoubleSide });

        // Create top and bottom discs as separate meshes for flap animation
        const topGeometry = new THREE.CircleGeometry(radius, segments);
        const bottomGeometry = new THREE.CircleGeometry(radius, segments);
        const topDisc = new THREE.Mesh(topGeometry, baseMaterial);
        const bottomDisc = new THREE.Mesh(bottomGeometry, baseMaterial);
        topDisc.position.y = height / 2;
        bottomDisc.position.y = -height / 2;
        scene.add(topDisc);
        scene.add(bottomDisc);

        // Create side surface (will be morphed during unwrapping)
        const sideGeometry = new THREE.CylinderGeometry(radius, radius, height, segments, 1, true);
        const sideSurface = new THREE.Mesh(sideGeometry, sideMaterial);
        scene.add(sideSurface);

        // Unwrapped rectangle geometry (initially scaled to 0 width)
        const unwrapGeometry = new THREE.PlaneGeometry(2 * Math.PI * radius, height);
        const unwrapSurface = new THREE.Mesh(unwrapGeometry, sideMaterial);
        unwrapSurface.position.z = radius;
        unwrapSurface.rotation.x = Math.PI/2;
        unwrapSurface.scale.x = 0; // Start fully wrapped
        scene.add(unwrapSurface);

        // Camera position
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        // Slider elements
        const flapAngleSlider = document.getElementById('flapAngle');
        const unwrapFactorSlider = document.getElementById('unwrapFactor');

        // Animation function
        function animate() {
            requestAnimationFrame(animate);

            // Get slider values
            const flapAngle = THREE.MathUtils.degToRad(parseFloat(flapAngleSlider.value));
            const unwrapFactor = parseFloat(unwrapFactorSlider.value);

            // Update disc flap angles (rotate around an edge point)
            topDisc.rotation.z = flapAngle;
            bottomDisc.rotation.z = -flapAngle;
            // Adjust position to rotate around edge
            topDisc.position.set(radius * (1 - Math.cos(flapAngle)), height / 2, radius * Math.sin(flapAngle));
            bottomDisc.position.set(radius * (1 - Math.cos(flapAngle)), -height / 2, -radius * Math.sin(flapAngle));

            // Update side surface based on unwrap factor
            if (unwrapFactor > 0) {
                sideSurface.scale.x = 1 - unwrapFactor;
                sideSurface.scale.z = 1 - unwrapFactor;
                unwrapSurface.scale.x = unwrapFactor;
            } else {
                sideSurface.scale.set(1, 1, 1);
                unwrapSurface.scale.x = 0;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize for responsive design
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unfolding Cylinder - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
        }
        label { display: block; margin-top: 10px; }
        input[type="range"] { width: 200px; }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label for="flapAngle">Disc Flap Angle (0-90Â°): <span id="flapAngleValue">0</span></label>
            <input type="range" id="flapAngle" min="0" max="90" value="0">
        </div>
        <div>
            <label for="unwrapSurface">Surface Unwrap (0-1): <span id="unwrapSurfaceValue">0.0</span></label>
            <input type="range" id="unwrapSurface" min="0" max="1" value="0" step="0.01">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let cylinderGroup, topBase, bottomBase, lateralSurface, unwrappedSurface;
        let topPivot, bottomPivot;

        const cylinderRadius = 2;
        const cylinderHeight = 4;
        const segments = 64; // More segments for smoother curves

        const baseColor = 0x0077ff; // Blue
        const surfaceColor = 0xff8800; // Orange
        const unwrappedSurfaceColor = 0xffaa00; // Lighter Orange

        // Sliders
        const flapAngleSlider = document.getElementById('flapAngle');
        const unwrapSurfaceSlider = document.getElementById('unwrapSurface');
        const flapAngleValueSpan = document.getElementById('flapAngleValue');
        const unwrapSurfaceValueSpan = document.getElementById('unwrapSurfaceValue');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 8);
            camera.lookAt(0,0,0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Cylinder Group - to move all parts together if needed
            cylinderGroup = new THREE.Group();
            scene.add(cylinderGroup);

            // Materials
            const baseMaterial = new THREE.MeshStandardMaterial({ color: baseColor, side: THREE.DoubleSide });
            const surfaceMaterial = new THREE.MeshStandardMaterial({ color: surfaceColor, side: THREE.DoubleSide });
            const unwrappedSurfaceMaterial = new THREE.MeshStandardMaterial({ color: unwrappedSurfaceColor, side: THREE.DoubleSide, transparent: true, opacity: 0 });


            // --- Create Cylinder Parts ---

            // Top Base
            const baseGeometry = new THREE.CircleGeometry(cylinderRadius, segments);
            topBase = new THREE.Mesh(baseGeometry, baseMaterial);
            topBase.rotation.x = Math.PI / 2; // Orient it flat
            topBase.position.y = cylinderHeight / 2; // Position relative to its pivot

            // Bottom Base
            bottomBase = new THREE.Mesh(baseGeometry.clone(), baseMaterial);
            bottomBase.rotation.x = -Math.PI / 2; // Orient it flat
            bottomBase.position.y = -cylinderHeight / 2; // Position relative to its pivot

            // Pivots for bases
            // Position pivot at the edge of the cylinder where the flap will rotate
            topPivot = new THREE.Group();
            topPivot.position.set(cylinderRadius, cylinderHeight / 2, 0); // Pivot point on the circumference
            cylinderGroup.add(topPivot);
            topBase.position.set(-cylinderRadius, 0, 0); // Position base relative to the pivot
            topPivot.add(topBase);
            // Initial rotation correction due to pivot placement
            topPivot.rotation.y = Math.PI / 2;


            bottomPivot = new THREE.Group();
            bottomPivot.position.set(cylinderRadius, -cylinderHeight / 2, 0);
            cylinderGroup.add(bottomPivot);
            bottomBase.position.set(-cylinderRadius, 0, 0);
            bottomPivot.add(bottomBase);
            // Initial rotation correction
            bottomPivot.rotation.y = Math.PI / 2;


            // Lateral Surface (the part that shrinks)
            // This will have its thetaLength animated
            const lateralGeometry = new THREE.CylinderGeometry(
                cylinderRadius, cylinderRadius, cylinderHeight, segments, 1, true // true for openEnded
            );
            lateralSurface = new THREE.Mesh(lateralGeometry, surfaceMaterial);
            cylinderGroup.add(lateralSurface);

            // Unwrapped Surface (the rectangle that grows)
            // Width is circumference (2 * PI * r), height is cylinderHeight
            const unwrappedWidth = 2 * Math.PI * cylinderRadius;
            const unwrappedGeometry = new THREE.PlaneGeometry(unwrappedWidth, cylinderHeight, segments, 1);
            unwrappedSurface = new THREE.Mesh(unwrappedGeometry, unwrappedSurfaceMaterial);
            unwrappedSurface.position.y = 0; // Centered with the cylinder
            // Position it so it "unrolls" from one edge of the cylinder.
            // The lateralSurface opens towards positive X by default due to thetaStart=0
            // So, the unwrapped plane should appear to the "right" of the cylinder's opening.
            // Its center will be at half its width, offset from the cylinder's edge.
            unwrappedSurface.position.x = cylinderRadius + unwrappedWidth / 2;
            unwrappedSurface.rotation.y = Math.PI / 2; // Make it face "outwards" if needed, or align with opening
            unwrappedSurface.visible = false; // Initially hidden
            cylinderGroup.add(unwrappedSurface);


            // Orbit Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Event Listeners
            flapAngleSlider.addEventListener('input', onFlapAngleChange);
            unwrapSurfaceSlider.addEventListener('input', onUnwrapSurfaceChange);
            window.addEventListener('resize', onWindowResize);

            // Initial update based on sliders
            onFlapAngleChange();
            onUnwrapSurfaceChange();

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onFlapAngleChange() {
            const angleDegrees = parseFloat(flapAngleSlider.value);
            flapAngleValueSpan.textContent = angleDegrees.toFixed(0);
            const angleRadians = THREE.MathUtils.degToRad(angleDegrees);

            // Rotate around the Z-axis of the pivot (which is aligned with the cylinder's side)
            topPivot.rotation.z = -angleRadians; // Negative to open "outwards"
            bottomPivot.rotation.z = angleRadians; // Positive to open "outwards"
        }

        function onUnwrapSurfaceChange() {
            const unwrapFactor = parseFloat(unwrapSurfaceSlider.value);
            unwrapSurfaceValueSpan.textContent = unwrapFactor.toFixed(2);

            // Animate the lateral surface (cylindrical part)
            const originalThetaLength = 2 * Math.PI;
            const currentThetaLength = originalThetaLength * (1 - unwrapFactor);

            // Recreate or update geometry for the lateral surface
            // Simpler to recreate if performance allows, more complex to update vertices
            cylinderGroup.remove(lateralSurface);
            lateralSurface.geometry.dispose(); // Dispose old geometry

            // Ensure thetaStart allows the opening to be consistent with unwrapped plane
            const thetaStart = 0; // Let it open along the positive X-axis in its local space

            const newLateralGeometry = new THREE.CylinderGeometry(
                cylinderRadius, cylinderRadius, cylinderHeight, segments, 1, true,
                thetaStart, currentThetaLength
            );
            lateralSurface = new THREE.Mesh(newLateralGeometry, lateralSurface.material);
            cylinderGroup.add(lateralSurface);

            // Animate the unwrapped surface (rectangular part)
            if (unwrapFactor > 0.001) { // Only show if unwrapping has started
                unwrappedSurface.visible = true;
                unwrappedSurface.material.opacity = unwrapFactor; // Fade in

                // The plane geometry's width is the full circumference.
                // We scale its X-axis to reveal it.
                unwrappedSurface.scale.x = unwrapFactor;

                // Adjust position so it appears to unroll from the edge.
                // The plane is initially centered at cylinderRadius + fullWidth / 2.
                // When scale.x is unwrapFactor, its effective width is fullWidth * unwrapFactor.
                // Its new center should be cylinderRadius + (fullWidth * unwrapFactor) / 2.
                const fullWidth = 2 * Math.PI * cylinderRadius;
                unwrappedSurface.position.x = cylinderRadius + (fullWidth * unwrapFactor) / 2;

            } else {
                unwrappedSurface.visible = false;
                unwrappedSurface.material.opacity = 0;
            }

            // Position the opening of the cylinder and the start of the plane
            // The cylinder geometry by default starts at thetaStart = 0 (positive X axis).
            // We want the opening to be where the plane unrolls.
            // The unwrapped plane is positioned to the "right" (positive X in cylinderGroup's local space)
            // of the cylinder's edge at (radius, y, 0).
            // No extra rotation needed for lateralSurface if thetaStart handles the opening direction.
        }


        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
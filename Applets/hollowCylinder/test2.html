<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unfolding Cylinder - Three.js (Corrected)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            z-index: 1;
        }
        label { display: block; margin-top: 10px; }
        input[type="range"] { width: 200px; }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label for="flapAngle">Disc Flap Angle (0-90Â°): <span id="flapAngleValue">0</span></label>
            <input type="range" id="flapAngle" min="0" max="90" value="0">
        </div>
        <div>
            <label for="unwrapSurface">Surface Unwrap (0-1): <span id="unwrapSurfaceValue">0.0</span></label>
            <input type="range" id="unwrapSurface" min="0" max="1" value="0" step="0.01">
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let cylinderGroup, topBase, bottomBase, lateralSurface, unwrappedSurface;
        let topPivot, bottomPivot;

        const cylinderRadius = 2;
        const cylinderHeight = 4;
        const segments = 64;

        const baseColor = 0x0077ff;
        const surfaceColor = 0xff8800;
        const unwrappedSurfaceColor = 0xffaa00; // Lighter orange for unwrapped part

        const flapAngleSlider = document.getElementById('flapAngle');
        const unwrapSurfaceSlider = document.getElementById('unwrapSurface');
        const flapAngleValueSpan = document.getElementById('flapAngleValue');
        const unwrapSurfaceValueSpan = document.getElementById('unwrapSurfaceValue');

        // Store original full circumference for the plane
        const fullCircumference = 2 * Math.PI * cylinderRadius;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 4, 7); // Adjusted for a better initial view
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            cylinderGroup = new THREE.Group();
            scene.add(cylinderGroup);

            const baseMaterial = new THREE.MeshStandardMaterial({ color: baseColor, side: THREE.DoubleSide });
            const surfaceMaterial = new THREE.MeshStandardMaterial({ color: surfaceColor, side: THREE.DoubleSide });
            const unwrappedSurfaceMaterial = new THREE.MeshStandardMaterial({
                color: unwrappedSurfaceColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0
            });

            // Top Base
            const baseGeometry = new THREE.CircleGeometry(cylinderRadius, segments);
            topBase = new THREE.Mesh(baseGeometry, baseMaterial);
            topBase.rotation.x = Math.PI / 2;

            // Bottom Base
            bottomBase = new THREE.Mesh(baseGeometry.clone(), baseMaterial);
            bottomBase.rotation.x = -Math.PI / 2;

            // Pivots for bases
            topPivot = new THREE.Group();
            topPivot.position.set(cylinderRadius, cylinderHeight / 2, 0); // Pivot point on circumference
            cylinderGroup.add(topPivot);
            topBase.position.set(-cylinderRadius, 0, 0); // Position base center relative to pivot's origin
            topPivot.add(topBase);

            bottomPivot = new THREE.Group();
            bottomPivot.position.set(cylinderRadius, -cylinderHeight / 2, 0);
            cylinderGroup.add(bottomPivot);
            bottomBase.position.set(-cylinderRadius, 0, 0);
            bottomPivot.add(bottomBase);
            // REMOVED: topPivot.rotation.y and bottomPivot.rotation.y assignments

            // Lateral Surface (the part that shrinks/changes angle)
            // Initial geometry, will be updated in onUnwrapSurfaceChange
            const initialLateralGeometry = new THREE.CylinderGeometry(
                cylinderRadius, cylinderRadius, cylinderHeight, segments, 1, true, 0, 2 * Math.PI
            );
            lateralSurface = new THREE.Mesh(initialLateralGeometry, surfaceMaterial);
            cylinderGroup.add(lateralSurface);

            // Unwrapped Surface (the rectangle that grows)
            // PlaneGeometry: width, height. Creates in XY plane, width along X, height along Y.
            const unwrappedGeometry = new THREE.PlaneGeometry(fullCircumference, cylinderHeight, segments, 1);
            unwrappedSurface = new THREE.Mesh(unwrappedGeometry, unwrappedSurfaceMaterial);
            unwrappedSurface.position.y = 0; // Centered vertically with the cylinder
            // Initial position for scale=0 (will be updated, but ensures correct alignment thinking)
            unwrappedSurface.position.x = cylinderRadius;
            unwrappedSurface.rotation.y = 0; // Explicitly set, plane extends along +X from its center if not offset
            unwrappedSurface.visible = false;
            cylinderGroup.add(unwrappedSurface);

            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            flapAngleSlider.addEventListener('input', onFlapAngleChange);
            unwrapSurfaceSlider.addEventListener('input', onUnwrapSurfaceChange);
            window.addEventListener('resize', onWindowResize);

            onFlapAngleChange();
            onUnwrapSurfaceChange(); // Call to set initial state based on slider value 0

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onFlapAngleChange() {
            const angleDegrees = parseFloat(flapAngleSlider.value);
            flapAngleValueSpan.textContent = angleDegrees.toFixed(0);
            const angleRadians = THREE.MathUtils.degToRad(angleDegrees);

            // Rotate around the Z-axis of the pivot (tangent to cylinder side at the pivot point)
            topPivot.rotation.z = -angleRadians;
            bottomPivot.rotation.z = angleRadians;
        }

        function onUnwrapSurfaceChange() {
            const unwrapFactor = parseFloat(unwrapSurfaceSlider.value);
            unwrapSurfaceValueSpan.textContent = unwrapFactor.toFixed(2);

            const originalThetaLength = 2 * Math.PI;

            // --- Update Lateral Surface (Cylindrical Part) ---
            // This part represents the portion of the cylinder that is still rolled up.
            // It starts from the angle where unwrapping has occurred and extends for the remaining length.
            const newThetaStart = originalThetaLength * unwrapFactor;
            const newThetaLength = originalThetaLength * (1 - unwrapFactor);

            cylinderGroup.remove(lateralSurface);
            if (lateralSurface.geometry) lateralSurface.geometry.dispose();

            // Handle edge case for thetaLength being extremely small or zero for full unwrap
            if (newThetaLength < 0.0001) {
                 lateralSurface.visible = false; // Hide if effectively zero length
            } else {
                const newLateralGeometry = new THREE.CylinderGeometry(
                    cylinderRadius, cylinderRadius, cylinderHeight, segments, 1, true,
                    newThetaStart, newThetaLength
                );
                const surfaceMaterial = new THREE.MeshStandardMaterial({ color: surfaceColor, side: THREE.DoubleSide });
                lateralSurface = new THREE.Mesh(newLateralGeometry, surfaceMaterial);
                cylinderGroup.add(lateralSurface);
                lateralSurface.visible = true;
            }


            // --- Update Unwrapped Surface (Rectangular Part) ---
            // This plane represents the unwrapped portion. Its width corresponds to unwrapFactor * circumference.
            // It is created with the full_circumference and then scaled.
            // Its left edge should align with the cylinder's surface at theta=0 (world X = cylinderRadius).

            if (unwrapFactor > 0.001) {
                unwrappedSurface.visible = true;
                unwrappedSurface.material.opacity = 1; // Keep it fully opaque once visible, or use unwrapFactor for fade

                // Scale the plane (which has original width = fullCircumference)
                unwrappedSurface.scale.x = unwrapFactor;

                // Position the plane:
                // Its local center is at (0,0). Its original width is fullCircumference.
                // Scaled width is fullCircumference * unwrapFactor.
                // We want its *left edge* (local -fullCircumference/2 * scale.x) to be at world_x = cylinderRadius.
                // world_x_center + (local_x_left_edge * scale.x) = cylinderRadius
                // world_x_center - (fullCircumference/2 * unwrapFactor) = cylinderRadius
                // world_x_center = cylinderRadius + (fullCircumference * unwrapFactor) / 2
                unwrappedSurface.position.x = cylinderRadius + (fullCircumference * unwrapFactor) / 2;

            } else {
                unwrappedSurface.visible = false;
                unwrappedSurface.material.opacity = 0;
                unwrappedSurface.scale.x = 0; // Ensure scale is zero
                unwrappedSurface.position.x = cylinderRadius; // Reset position
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            // controls.update(); // if enableDamping or autoRotate is true
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
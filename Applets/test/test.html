<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unwrap Cyllinder</title>
    <style>
      body {
        margin: 0;
        background-color: pink;
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
      #container {
        width: 650px;
        height: 400px;
        border: 3px solid black;
      }
      
    </style>
  </head>
  <body>
    <div id="wrapper" style="position: relative; width: 650px; height: 400px;">
      <div id="container"></div>
      <svg id="labelOverlay" width="650" height="400" style="position:absolute; top:0; left:0; pointer-events: none;"></svg>
    </div>
    <input type="range" id="segments" min="4" max="50" value="12" step="2" />
    <button id="nextButton">Next</button>
    <button id="combineButton">Combine</button>

    <script src="three.min.js"></script>

    <script>
      function linearAnimate(obj, prop, start, end, duration) {
        let startTime = null;
        const change = end - start;

        function step(timestamp) {
          if (!startTime) startTime = timestamp;
          const progress = timestamp - startTime;
          const t = Math.min(progress / duration, 1);
          obj[prop] = start + change * t;

          if (t < 1) {
            window.requestAnimationFrame(step);
          } else {
            obj[prop] = end;
          }
        }

        window.requestAnimationFrame(step);
      }

      const container = document.getElementById("container");
      const segmentSlider = document.getElementById("segments");
      const nextButton = document.getElementById("nextButton");
      const combineButton = document.getElementById("combineButton");
      let numberOfSectors = 12; // How many pieces to make the cylinder
      const cylinderRadius = 1.5;
      const cylinderHeight = 1;
      let anglePerSector = (2 * Math.PI) / numberOfSectors;
      const aspectRatio = 650 / 400,
        d = 3;
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(
        -d * aspectRatio,
        d * aspectRatio,
        d,
        -d,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(650, 400);
      renderer.setPixelRatio(window.devicePixelRatio); // for crispness
      container.appendChild(renderer.domElement);

      renderer.setClearColor(0xffffff); // White background
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      camera.up.set(0, 0, 1);
      camera.position.set(-1, cylinderRadius * 2, cylinderHeight * 1.25);
      camera.lookAt(0, 0, 0);

      function worldToScreenPosition(position) {
        const vector = position.clone(); 
        vector.project(camera); 
        const canvas = renderer.domElement;
        const x = (vector.x * 0.5 + 0.5) * canvas.clientWidth;
        const y = (1 - (vector.y * 0.5 + 0.5)) * canvas.clientHeight;

        return { x, y };
      }

      const geometry = new THREE.PlaneGeometry(10, 10);
      const material = new THREE.MeshStandardMaterial({
        color: 0xdddddd,
      });
      const plane = new THREE.Mesh(geometry, material);
      scene.add(plane);

      //Create a pie group
      function createPie(radius, startAngle, endAngle, height, index) {
        const group = new THREE.Group();
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        const x1 = radius * Math.cos(startAngle),
          y1 = radius * Math.sin(startAngle),
          x2 = radius * Math.cos(endAngle),
          y2 = radius * Math.sin(endAngle);
        shape.lineTo(x1, y1);
        shape.absarc(0, 0, cylinderRadius, startAngle, endAngle, false);
        shape.lineTo(0, 0);
        const extrudeSettings = {
          steps: 1,
          depth: height,
          bevelEnabled: false,
        };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(index / numberOfSectors, 0.7, 0.5), // Different color for each sector
          roughness: 0.5,
          metalness: 0.2,
          side: THREE.DoubleSide, // Useful if there are tiny gaps, or if you want to see inside
        });
        const sectorMesh = new THREE.Mesh(geometry, material);

        // Define edge points
        const z0 = 0;
        const z1 = height,
          x1a = x1 * 1.001,
          y1a = y1 * 1.001,
          x2a = x2 * 1.001,
          y2a = y2 * 1.001;

        // Arc start and end points
        const p1 = new THREE.Vector3(x1a, y1a, z0);
        const p2 = new THREE.Vector3(x2a, y2a, z0);
        const p3 = new THREE.Vector3(x1a, y1a, z1);
        const p4 = new THREE.Vector3(x2a, y2a, z1);

        // Center top and bottom
        const c0 = new THREE.Vector3(0, 0, z0);
        const c1 = new THREE.Vector3(0, 0, z1);

        // Points to draw key edges
        const edgePoints = [
          // Top face
          c1,
          p3,
          p4,
          c1,

          // Vertical side edges
          p1,
          p3,
          p2,
          p4,
          c0,
          c1,
        ];

        const edgeGeometry = new THREE.BufferGeometry().setFromPoints(
          edgePoints
        );
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 });
        const lines = new THREE.LineSegments(edgeGeometry, lineMaterial);
        group.add(lines);
        const arcCurve = new THREE.ArcCurve(
          0,
          0, // center (x, y)
          cylinderRadius, // radius
          startAngle,
          endAngle, // startAngle, endAngle (in radians)
          false // clockwise
        );

        const points = arcCurve
          .getPoints(30)
          .map((p) => new THREE.Vector3(p.x, p.y, height)); // More points = smoother curve
        const arcgeometry = new THREE.BufferGeometry().setFromPoints(points);

        const arc = new THREE.Line(arcgeometry, lineMaterial);
        group.add(arc);

        group.add(sectorMesh);
        return group;
      }
      // --- Parameters for the cylinder and sectors ---
      let midAngles;
      let pieArray, bottomHalf, topHalf;

      function renderPies(val) {
        if (pieArray) pieArray.forEach((p) => scene.remove(p));
        numberOfSectors = val;
        anglePerSector = (2 * Math.PI) / val;
        const pointsArray = Array.from(
          { length: numberOfSectors },
          (_, i) => (i * 2 * Math.PI) / numberOfSectors
        );
        midAngles = pointsArray.map((a) => a + anglePerSector / 2);
        pointsArray.push(pointsArray[0]);
        pieArray = Array.from({ length: numberOfSectors }, (_, i) =>
          createPie(
            cylinderRadius,
            pointsArray[i],
            pointsArray[i + 1],
            cylinderHeight,
            i
          )
        );
        bottomHalf = pieArray.slice(0, numberOfSectors / 2);
        topHalf = pieArray.slice(numberOfSectors / 2);
        pieArray.forEach((pie) => scene.add(pie));
      }
      renderPies(12);
      function handleNext() {
        const halfWedgeWidth = cylinderRadius * Math.sin(anglePerSector / 2);
        const offsetx = (bottomHalf.length - 1) * halfWedgeWidth;
        bottomHalf.forEach((pie, i) => {
          linearAnimate(
            pie.position,
            "x",
            pie.position.x,
            -2 * halfWedgeWidth * i + offsetx,
            1000
          );
          linearAnimate(
            pie.rotation,
            "z",
            pie.rotation.z,
            Math.PI / 2 - midAngles[i],
            1000
          );
        });
        topHalf.forEach((pie, i) => {
          linearAnimate(
            pie.position,
            "x",
            pie.position.x,
            2 * halfWedgeWidth * i - offsetx + halfWedgeWidth,
            1000
          );
          linearAnimate(
            pie.rotation,
            "z",
            pie.rotation.z,
            Math.PI / 2 - midAngles[i],
            1000
          );
        });
      }

      nextButton.addEventListener("click", handleNext);

      function handleCombine() {
        const offset = (cylinderRadius * Math.cos(anglePerSector / 2)) / 2;
        bottomHalf.forEach((pie, i) => {
          linearAnimate(pie.position, "y", pie.position.y, -offset, 1000);
        });
        topHalf.forEach((pie, i) => {
          linearAnimate(pie.position, "y", pie.position.y, offset, 1000);
        });
      }
      combineButton.addEventListener("click", handleCombine);
      segmentSlider.addEventListener("input", () => {
        renderPies(segmentSlider.value);
      });
      const overlay = document.getElementById("labelOverlay");

// Add a test SVG line
const ns = "http://www.w3.org/2000/svg";

const line = document.createElementNS(ns, "line");
line.setAttribute("x1", 50);
line.setAttribute("y1", 50);
line.setAttribute("x2", 200);
line.setAttribute("y2", 200);
line.setAttribute("stroke", "red");
line.setAttribute("stroke-width", "2");
overlay.appendChild(line);

// Add a test SVG text label
const text = document.createElementNS(ns, "text");
text.setAttribute("x", 60);
text.setAttribute("y", 45);
text.setAttribute("fill", "blue");
text.setAttribute("font-size", "16");
text.textContent = "Test Label";
overlay.appendChild(text);
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      animate(); // Call this once to start rendering


    </script>
  </body>
</html>

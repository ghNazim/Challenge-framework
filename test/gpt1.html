<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Unwrap Cyllinder</title>
    <style>
      body {
        margin: 0;
        background-color: pink;
        flex-direction: column;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
      #container {
        width: 650px;
        height: 400px;
        border: 3px solid black;
      }
      input {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <input id="rotateAngle" type="range" min="0" max="360" value="0" step="1" />
    <input
      id="translateSlider"
      type="range"
      min="0"
      max="5"
      value="0"
      step="0.1"
    />
    <button id="nextButton">Next</button>
    <button id="combineButton">Combine</button>

    <script src="three.min.js"></script>

    <script>
      const container = document.getElementById("container");
      const rotateSlider = document.getElementById("rotateAngle");
      const translateSlider = document.getElementById("translateSlider");
      const nextButton = document.getElementById("nextButton");
      const combineButton = document.getElementById("combineButton");

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        650 / 400, // aspect ratio matches div
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(650, 400);
      renderer.setPixelRatio(window.devicePixelRatio); // for crispness
      container.appendChild(renderer.domElement);
      renderer.setClearColor(0xffffff); // White background

      // Create a plane geometry (width, height)
      const geometry = new THREE.PlaneGeometry(10, 10);

      // Create a basic material
      const material = new THREE.MeshStandardMaterial({
        color: 0xdddddd,
      });

      // Create the mesh
      const plane = new THREE.Mesh(geometry, material);

      // Add to the scene
      scene.add(plane);

      //Create a pie group
      function createPie(radius, startAngle, endAngle, height, index) {
        const group = new THREE.Group();
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        const x1 = radius * Math.cos(startAngle),
          y1 = radius * Math.sin(startAngle),
          x2 = radius * Math.cos(endAngle),
          y2 = radius * Math.sin(endAngle);
        shape.lineTo(x1, y1);
        shape.absarc(0, 0, cylinderRadius, startAngle, endAngle, false);
        shape.lineTo(0, 0);
        const extrudeSettings = {
          steps: 1,
          depth: height,
          bevelEnabled: false,
        };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(index / numberOfSectors, 0.7, 0.5), // Different color for each sector
          roughness: 0.5,
          metalness: 0.2,
          side: THREE.DoubleSide, // Useful if there are tiny gaps, or if you want to see inside
        });
        const sectorMesh = new THREE.Mesh(geometry, material);

        // Define edge points
        const z0 = 0;
        const z1 = height;

        // Arc start and end points
        const p1 = new THREE.Vector3(x1, y1, z0);
        const p2 = new THREE.Vector3(x2, y2, z0);
        const p3 = new THREE.Vector3(x1, y1, z1);
        const p4 = new THREE.Vector3(x2, y2, z1);

        // Center top and bottom
        const c0 = new THREE.Vector3(0, 0, z0);
        const c1 = new THREE.Vector3(0, 0, z1);

        // Points to draw key edges
        const edgePoints = [
          // Top face
          c1,
          p3,
          p4,
          c1,

          // Vertical side edges
          p1,
          p3,
          p2,
          p4,
        ];

        const edgeGeometry = new THREE.BufferGeometry().setFromPoints(
          edgePoints
        );
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const lines = new THREE.LineSegments(edgeGeometry, lineMaterial);
        group.add(lines);
        const arcCurve = new THREE.ArcCurve(
          0,
          0, // center (x, y)
          cylinderRadius, // radius
          startAngle,
          endAngle, // startAngle, endAngle (in radians)
          false // clockwise
        );

        const points = arcCurve
          .getPoints(30)
          .map((p) => new THREE.Vector3(p.x, p.y, height)); // More points = smoother curve
        const arcgeometry = new THREE.BufferGeometry().setFromPoints(points);
        const arcmaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const arc = new THREE.Line(arcgeometry, arcmaterial);
        group.add(arc);

        group.add(sectorMesh);
        return group;
      }
      // --- Parameters for the cylinder and sectors ---
      const numberOfSectors = 12; // How many pieces to make the cylinder
      const cylinderRadius = 1.5;
      const cylinderHeight = 1; // This will be the extrusion depth
      const anglePerSector = (2 * Math.PI) / numberOfSectors;
      const pointsArray = Array.from(
        { length: numberOfSectors },
        (_, i) => (i * 2 * Math.PI) / numberOfSectors
      );
      const midAngles = pointsArray.map((a) => a + anglePerSector / 2);
      pointsArray.push(pointsArray[0]);

      const pieArray = Array.from({ length: numberOfSectors }, (_, i) =>
        createPie(
          cylinderRadius,
          pointsArray[i],
          pointsArray[i + 1],
          cylinderHeight,
          i
        )
      );
      const bottomHalf = pieArray.slice(0, numberOfSectors / 2);
      const topHalf = pieArray.slice(numberOfSectors / 2);
      pieArray.forEach((pie) => scene.add(pie));

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      camera.up.set(0, 0, 1);
      camera.position.set(0, cylinderRadius * 2.2, cylinderHeight * 2);
      camera.lookAt(0, 0, 0);
      function animateRearrange(
        pies,
        targetRotations,
        targetPositions,
        duration
      ) {
        const startRotations = pies.map((pie) => pie.rotation.z);
        const startPositions = pies.map((pie) => pie.position.clone());

        const clock = new THREE.Clock();

        function animate() {
          const elapsed = clock.getElapsedTime();
          const progress = Math.min(elapsed / duration, 1);

          pies.forEach((pie, i) => {
            pie.rotation.z = THREE.MathUtils.lerp(
              startRotations[i],
              targetRotations[i],
              progress
            );
            pie.position.lerpVectors(
              startPositions[i],
              targetPositions[i],
              progress
            );
          });

          renderer.render(scene, camera);

          if (progress < 1) {
            requestAnimationFrame(animate);
          }
        }

        animate();
      }

      function handleNext() {
        const halfWedgeWidth = cylinderRadius * Math.sin(anglePerSector / 2);
        const offsetx = (bottomHalf.length - 1) * halfWedgeWidth;
        const targetRotations = midAngles.map((angle) => Math.PI / 2 - angle);
        const targetPositionsBottom = bottomHalf.map(
          (_, i) => new THREE.Vector3(-2 * halfWedgeWidth * i + offsetx, 0, 0)
        );
        const targetPositionsTop = topHalf.map(
          (_, i) =>
            new THREE.Vector3(
              -2 * halfWedgeWidth * i + offsetx + halfWedgeWidth,
              0,
              0
            )
        );

        animateRearrange(
          bottomHalf,
          targetRotations.slice(0, numberOfSectors / 2),
          targetPositionsBottom,
          2
        );
        animateRearrange(
          topHalf,
          targetRotations.slice(numberOfSectors / 2),
          targetPositionsTop,
          2
        );
      }

      function handleCombine() {
        const offset = (cylinderRadius * Math.cos(anglePerSector / 2)) / 2;
        const targetPositionsBottom = bottomHalf.map((pie) =>
          pie.position.clone().setY(-offset)
        );
        const targetPositionsTop = topHalf.map((pie) =>
          pie.position.clone().setY(offset)
        );

        animateRearrange(
          bottomHalf,
          bottomHalf.map((pie) => pie.rotation.z),
          targetPositionsBottom,
          2
        );
        animateRearrange(
          topHalf,
          topHalf.map((pie) => pie.rotation.z),
          targetPositionsTop,
          2
        );
      }

      nextButton.addEventListener("click", handleNext);

      combineButton.addEventListener("click", handleCombine);

      renderer.render(scene, camera);
    </script>
  </body>
</html>
